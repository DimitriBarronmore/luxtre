#!/usr/bin/env luajit
local curr_location = arg[0]:gsub("luxtre/bin/luxc$", "")

package.path = package.path .. ";" .. arg[0]:gsub("luxtre/bin/luxc$", "") .. "?.lua"
-- local loader = require(arg[0] .. "/loader")

local data = require("luxtre.utils.data")
data.__binary_prefix = curr_location
local loader = require("luxtre.init")
loader.register()

--[[USAGE:
    luxc [folder]
    flags:
        -d / --maxdepth <num>: set max recursion depth, default 1
            does nothing if -R is not set
        -r / --recursive : compile in subfolders recursively
        -f / --full : compiles all files in directory, not just recently edited ones
        -s : silent mode, disables printing
        -s / --list : prints filenames, does not compile
--]]

local marker_name = "luxc_mark"

local realargs = {}
local capturemore = {
    ["--maxdepth"] = true,
    -- ["-d"] = true,
}
local aliases = {
    ["-d"] = "--maxdepth",
    ["-r"] = "--recursive",
    ["-f"] = "--full",
    ["-l"] = "--list"
}
local capd = {}
for k,v in ipairs(arg) do
    -- print(k, v)
    if v:match("^%-") and not capd[v] then
        if aliases[v] then
            v = aliases[v]
        end
        if capturemore[v] then
            local capture = arg[k + 1]
            if capture == nil then
                error("argument " .. v .. " requires a value", 0)
            end
            capd[arg[k + 1]] = true
            realargs[v] = capture
        else
            realargs[v] = true
        end
        -- realargs[v] = true
    elseif not capd[v] then
        table.insert(realargs, v)
    end
end

-- local print = print
local pfunc
if realargs["-s"] then
    pfunc = function() end
else
    pfunc = function(...)
        io.write(...)
        io.output():flush()
    end
end

local rdepth = 1
if realargs["--recursive"] then
    rdepth = tonumber(realargs["--maxdepth"] or 0)
-- print(rdepth)
    if rdepth == nil then
        error("max recursion depth must be a number", 0)
    end
end

local exec_mode

if type(realargs[1]) == "string" then
    if realargs[1]:match("%.lux$") then
        exec_mode = "files"
    else
        exec_mode = "directory"
    end
else
    error("no file/folder name provided", 0)
end


-- Real Execution
if exec_mode == "files" then
    local errs = {}
    for _, filename in ipairs(realargs) do
        pfunc(filename .. "...")
        filename = filename:gsub("%.lux$", "")
        local res, err = pcall(loader.compile_file, filename)
        if res == false then
            table.insert(errs, filename .. ".lux: " .. err)
            -- error("lux: " .. err, 0)
            pfunc("error\n")
        else
            pfunc("done\n")
        end
    end
    if #errs == 0 then
        pfunc("all files compiled without errors\n")
    else
        pfunc("some errors encountered\n")
        for _, err in ipairs(errs) do
            print(err)
        end
    end

elseif exec_mode == "directory" then

    local dir
    if type(realargs[1]) == "string" then
        dir = realargs[1]
        if not dir:match("/^") then
            dir = dir .. "/"
        end
    else
        dir = "./"
    end

    if not realargs["--full"] then
        local f, e = io.open(dir .. marker_name, "r")
        if f == nil then
            realargs["--full"] = true
        else
            f:close()
        end
        -- print(f, e)
    end

    local depthtxt = "-maxdepth " .. rdepth
    if rdepth == 0 then
        depthtxt = ""
    end
    -- print(depthtext)

    local list 
    if realargs["--full"] then 
        list = io.popen(('find %s %s -name "*lux" -type f'):format(dir, depthtxt))
    else
        list = io.popen(('find %s -maxdepth %s -name "*lux" -type f -newer %s'):format(dir, rdepth, dir .. marker_name))
    end

    if not realargs["--list"] then
        local errs = {}
        for filename in list:lines() do
            pfunc(filename .. "...")
            filename = filename:gsub("%.lux$", "")
            local res, err = pcall(loader.compile_file, filename)
            if res == false then
                table.insert(errs, filename .. ".lux: " .. err)
                -- error("lux: " .. err, 0)
                pfunc("error\n")
            else
                pfunc("done\n")
            end
        end
        if #errs == 0 then
            pfunc("all files compiled without errors\n")
        else
            pfunc("some errors encountered\n")
            for _, err in ipairs(errs) do
                print(err)
            end
        end
    else
        print(list:read("*a"))
    end



    --[[ Marker disabled because it wasn't working properly. ]]

    -- local marker = io.open(dir .. marker_name, "w+")
    -- marker:write([[== DO NOT EDIT THIS FILE ==
    -- This file is used to mark the last time luxc ran in this directory, to avoid recompiling files which have not changeed.
    -- Updating this file's contents will cause any files edited prior to not compile on the next run until re-modified.
    -- If necessary, you can get around this by running luxc with the --full flag or deleting this file.]])
    -- marker:flush()
    -- marker:close()
end